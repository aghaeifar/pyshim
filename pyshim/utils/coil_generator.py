import os
import ctypes
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Line3DCollection


def yrot(angle_deg):
    """Y-axis rotation matrix."""
    angle_rad = np.deg2rad(angle_deg)
    return np.array([
        [np.cos(angle_rad), 0, np.sin(angle_rad)],
        [0, 1, 0],
        [-np.sin(angle_rad), 0, np.cos(angle_rad)]
    ])

def zrot(angle_deg):
    """Z-axis rotation matrix."""
    angle_rad = np.deg2rad(angle_deg)
    return np.array([
        [np.cos(angle_rad), -np.sin(angle_rad), 0],
        [np.sin(angle_rad), np.cos(angle_rad), 0],
        [0, 0, 1]
    ])

# --------------------------------------
# Coil Position Generator
# --------------------------------------

def coil_pos_make(z:np.ndarray, theta:np.ndarray, rCoil:np.ndarray, rCyln, div=16, shape='circle', is_vertical=False):
    """
    Generate spatial position of the coil for plotting and simulation.
    
    Parameters:
        z       : (n*1) array-like, elevation of the coil center for square and circular coils.
                  For irregular coils -> (n*div), n coils, each with "div" nodes.
        theta   : (n*1) array-like, angle between reference direction and coil center direction (in radians).
                  For irregular coils -> (n*div), n coils, each with "div" nodes.
        rCoil   : (n*1) or scalar, radius of coils.
        rCyln   : (n*1) or scalar, radius of cylinder.
        div     : int, subsegment of the coils or number of nodes for irregular coils. Default is 16.
        shape   : str, shape of the coils: 'circle', 'square', or 'irregular'. Default is 'circle'.
        is_vertical : bool, whether the coil is vertical. Default is False.
    
    Returns:
        coilpos : list of dict, each dict contains the spatial position of a coil.
    """

    # Validate inputs
    
    if not isinstance(z, np.ndarray):        
        z = np.array(z)
    z = z.ravel()
    if not isinstance(theta, np.ndarray):
        theta = np.array(theta)
    theta = theta.ravel()
    if not isinstance(rCoil, np.ndarray):
        rCoil = np.array(rCoil)
    rCoil = rCoil.ravel()
    if not isinstance(rCyln, np.ndarray):
        rCyln = np.array(rCyln)
    rCyln = rCyln.ravel()

    nCoil = z.size
    # Handle scalar inputs for rCoil and rCyln
    if rCoil.size == 1:
        rCoil = np.full(nCoil, rCoil).ravel()
    if rCyln.size == 1:
        rCyln = np.full(nCoil, rCyln).ravel()
    
    coilpos = []
    for j in range(nCoil):
        # Create coil based on shape
        if shape == 'square':
            d = div // 2
            coil = np.array([
                [0] * (2 * d),
                np.concatenate([np.linspace(-rCoil[j], rCoil[j], d), np.linspace(rCoil[j], -rCoil[j], d)]),
                np.concatenate([-rCoil[j] * np.ones(d), rCoil[j] * np.ones(d)])
            ])
        elif shape in ['circle', 'circular']:
            d = np.arange(1, div + 1)
            coil = np.array([
                [0] * div,
                rCoil[j] * np.cos(2 * np.pi / div * d),
                rCoil[j] * np.sin(2 * np.pi / div * d)
            ])
        else:
            raise ValueError("Unspecified coil shape")
        
        coil = np.hstack((coil, coil[:, [0]]))  # Close the loop
        
        # Apply vertical rotation if needed
        if is_vertical:
            for i in range(coil.shape[1]):
                coil[:, i] = yrot(90) @ coil[:, i]
                coil[0, i] += rCoil[j]
        
        # Project to cylinder surface
        for i in range(coil.shape[1]):
            phi = 90 - (180 - np.rad2deg(coil[1, i] / (rCyln[j] + coil[0, i]))) / 2
            coil[:, i] = zrot(phi) @ coil[:, i]
        
        coil[0, :] += rCyln[j]
        
        # Rotate and translate based on theta and z
        c3 = zrot(np.rad2deg(theta[j])) @ coil
        c3[2, :] += z[j]
        coilpos.append(np.array(c3))
    
    return coilpos


# --------------------------------------
# Coil Position Plotter
# --------------------------------------

def coil_pos_plot(coilpos, current=None, myCMap=None, LineWidth=2.5):
    """
    Plot the output data generated by the 'coil_pos_make' function.
    
    Parameters:
        coilpos  : list of dict, each containing coil position data.
        current  : list or None, currents corresponding to each coil.
                   If provided, colors represent current magnitudes.
        myCMap   : colormap, optional custom colormap (default is `plt.cm.jet`).
        LineWidth: float, line width for the plotted coils (default is 2.5).
    """
    # Initialize cylinder bounds
    xCyln, yCyln, zCyln = 0, 0, 0

    # Default colormap
    clr_seg = 1024
    if myCMap is None:
        myCMap = plt.cm.jet(np.linspace(0, 1, clr_seg))
    else:
        clr_seg = len(myCMap)
    
    # Compute color indices for each coil
    clr_ind = np.round(np.linspace(0, clr_seg - 1, len(coilpos))).astype(int)
    
    if current is not None:
        if len(current) != len(coilpos):
            raise ValueError("Size mismatch between number of coils and currents.")
        
        c_max, c_min = np.max(current), np.min(current)
        clr_ind = np.round((current - c_min) * (clr_seg - 1) / (c_max - c_min)).astype(int)
        clr_ind = np.clip(clr_ind, 0, clr_seg - 1)  # Ensure indices are valid
    
    # 3D Plotting
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    
    for c, coil in enumerate(coilpos):
        for d in range(coil.shape[1] - 1):
            # Extract line segment
            line = np.array([[coil[0, d], coil[1, d], coil[2, d]],
                             [coil[0, d + 1], coil[1, d + 1], coil[2, d + 1]]])
            # Create a line collection for the segment
            lc = Line3DCollection([line], linewidths=LineWidth, colors=[myCMap[clr_ind[c]]])
            ax.add_collection3d(lc)
        
        # Update bounds
        xCyln = max(xCyln, np.max(np.abs(coil[0, :])))
        yCyln = max(yCyln, np.max(np.abs(coil[1, :])))
        zCyln = max(zCyln, np.max(np.abs(coil[2, :])))
    
    # Label and view settings
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.view_init(elev=22, azim=145)
    ax.grid(True)

    # Axis limits
    margin = 1.1
    ax.set_xlim([-margin * xCyln, margin * xCyln])
    ax.set_ylim([-margin * yCyln, margin * yCyln])
    ax.set_zlim([-margin * zCyln, margin * zCyln])
    ax.axis('equal')# Equal aspect ratio

    # Add colorbar if current is provided
    if current is not None:
        c_min, c_max = np.min(current), np.max(current)
        sm = plt.cm.ScalarMappable(cmap='jet', norm=plt.Normalize(vmin=c_min, vmax=c_max))
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax)
        cbar.set_label('Current [A]')
    
    plt.show()


# --------------------------------------
# Test
# --------------------------------------
def ensure_3xN(array:np.ndarray):
    if array.ndim ==2 and array.shape[0] == 3: return array
    if array.ndim ==2 and array.shape[1] == 3: return array.T
    raise ValueError(f'Array must be of shape 3xN or Nx3 but is {array.shape}.')

def biot_savart_sim(coil_pos:np.ndarray, grid_xyz:np.ndarray):
    lib_folder = '/DATA/aaghaeifar/Nextcloud/Projects/Biot-Savart/lib/'
    coil_pos   = ensure_3xN(coil_pos).copy(order='F')  
    grid_xyz   = ensure_3xN(grid_xyz).copy(order='F')  
    b0_xyz     = np.zeros(dtype=np.float64, shape=(3, grid_xyz.shape[1]), order='F')

    handle = ctypes.CDLL(os.path.join(lib_folder, 'libbiot_savart.so'))
    handle.calculate_b0.argtypes = [ctypes.c_uint,
                                    np.ctypeslib.ndpointer(np.float64, ndim=coil_pos.ndim, flags='F'),
                                    np.ctypeslib.ndpointer(np.float64, ndim=coil_pos.ndim, flags='F'),
                                    ctypes.c_uint,
                                    np.ctypeslib.ndpointer(np.float64, ndim=grid_xyz.ndim, flags='F'),
                                    np.ctypeslib.ndpointer(np.float64, ndim=b0_xyz.ndim, flags='F')]

    coil_pos_start = coil_pos[:,:-1]
    coil_pos_end   = coil_pos[:,1:]
    handle.calculate_b0(coil_pos_start.shape[1], coil_pos_start, coil_pos_end, grid_xyz.shape[1], grid_xyz, b0_xyz) 
    return np.ascontiguousarray(b0_xyz)